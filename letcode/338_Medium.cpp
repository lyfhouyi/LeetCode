#include<iostream>
#include<vector>

using namespace std;

//给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
//
//进阶 :
//
//	给出时间复杂度为O(n * sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
//	要求算法的空间复杂度为O(n)。
//	你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。
//
//
//来源：力扣（LeetCode）
//链接：https ://leetcode-cn.com/problems/counting-bits
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


//解法一：递推。countBits[i] = countBits[i - 1] + 1 ，当 i 的最低位为 1 时，countBits[i / 2] ，当 i 的最低位为 0 时。
//vector<int> countBits(int num)
//{
//	vector<int> ret(num + 1);
//	for (int i = 1; i <= num; i++)
//	{
//		if (i & 1 == 1)
//			ret[i] = ret[i - 1] + 1;
//		else
//			ret[i] = ret[i >> 1];
//	}
//	return ret;
//}


//解法二：递推。countBits[i] = countBits[i >> 1] + (i & 1) 。
//vector<int> countBits(int num)
//{
//	vector<int> ret(num + 1);
//	for (int i = 1; i <= num; i++)
//	{
//		ret[i] = ret[i >> 1] + (i & 1);
//	}
//	return ret;
//}


//解法三：递推。countBits[i] = countBits[i & (i - 1)] + 1 。
vector<int> countBits(int num)
{
	vector<int> ret(num + 1);
	for (int i = 1; i <= num; i++)
	{
		ret[i] = ret[i & (i - 1)] + 1;
	}
	return ret;
}

int main338()
{
	vector<int> ret = countBits(5);
	cout << "main：ret = [";
	for (vector<int>::iterator it = ret.begin(); it != ret.end(); it++)
		cout << *it << ",";
	cout << "]" << endl;
	return 0;
}